# 프로세스(Process)
프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것을 말한다.
**운영체제로부터 자원(`주소 공간, 파일, 메모리`)을 할당받은 작업을 프로세스라고 한다.**
### [프로세스의 구조]
![](https://velog.velcdn.com/images/oyoungsun/post/54942e6c-300e-433d-82e7-20f688887eee/image.png)
`text` : 컴파일된 소스 코드를 저장\
`stack` : (함수의 매개변수, 복귀 주소, 로컬 변수)임시 자료 저장\
`data` : 전역 변수/초기화 된 데이터 저장\
`heap` : 실행 중에 동적으로 할당되는 메모리 저장
> ### 💡 프로세스와 프로그램의 차이는 무엇인가요?
>프로세스는 OS가 프로그램을 실행할 수 있도록, 자원을 할당해 메모리에 load되는 단위입니다.
즉, `실행중인 프로그램` 이라고 정의할 수 있다.
>
> 프로그램의 의미는 어떤 작업을 하기 위해 해야할 일들을 순서대로 나열한 것으로
컴퓨터에서 어떤 작업을 위해 실행할 수 있는 `정적인 상태`의 파일이라고 볼 수 있다.

### 프로세스 제어 블록(Process Control Block, PCB)
**특정 프로세스에 대한 중요한 정보를 저장하는 운영체제의 자료구조이다.**
운영체제가 프로세스를 관리하기 위해 프로세스의 생성시 함께 생성한다.
### 💡 왜 PCB가 필요할까?  : CPU는 한번에 하나의 프로세스만 수행하기 때문에!
`context switching, 문맥교환` : 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU 를 반환해야 하는데, 이때 작업의 진행 상황, 실행 위치(`PC`)등을 PCB에 저장한다.
해당 프로세스가 다시 CPU 를 할당받게 되면 PCB 에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 작업을 수행한다.

>PCB 에 저장되는 정보
> 
>`Process ID, PID` : 프로세스 식별번호\
프로세스 상태 : `new, ready, running, waiting, terminated` 등의 상태를 저장\
`PC, Program Counter` : 다음에 실행할 명령어의 주소\
CPU 레지스터\
CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등\
메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함\
입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록\
어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등\

# 스레드(Thread)
스레드는 프로세스의 실행 단위, 실행 흐름의 단위이다.

**한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.**

### 스레드 구조
![](https://velog.velcdn.com/images/oyoungsun/post/187bc7cb-42f2-4112-82f5-1dd7d84095ed/image.png)


스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다.\
**같은 프로세스에 속한 다른 스레드와 정적영역&a메모리(code, data, file, 신호, heap) 을 공유한다**.
**동적영역(stack, register)는 구분한다.**\
`멀티스레딩` : 하나의 프로세스를 다수의 실행 단위(스레드)로 구분하여 1) 자원을 공유하고 2) 자원의 생성과 관리의 중복성을 최소화하여 3)수행 능력을 향상시키는 것\
이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 `스택`과 `PC 레지스터 값`을 갖고 있다. 또한 이러한 독립 정보를 `TCB`를 통해 저장한다.

### 💡스택을 스레드마다 독립적으로 할당하는 이유
스택은 `함수 호출 시 전달되는 인자`, `되돌아갈 주소값` 및 `함수 내에서 선언하는 변수` 등을 저장하기 위해 사용되는 메모리 공간이다.\
**스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다=독립적인 실행 흐름이 가능하다**는 것이다.

### 💡 PC Register 를 스레드마다 독립적으로 할당하는 이유
PC 값은 스레드가 `명령어의 어디까지 수행하였는지`를 나타나게 된다. 스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다. 따라서 PC 레지스터를 독립적으로 할당한다.
### 결론
- 즉, 스레드 간 Stack에 속하는 함수 내 로컬변수는 공유될 수 없다.
- 스레드간 인스턴스 변수, 정적 변수는 공유할 수 있다.
### 💡 멀티 쓰레드 환경시 주의 사항
다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 lock, 동기화 기법을 통해 동시성 문제 또는 교착 상태(`dead-lock`)가 발생하지 않도록 주의해야 합니다.
# 스프링에서의 Heap 사용
> - `Java 힙 메모리` : 애플리케이션 내에서 실행 중인 모든 스레드가 액세스할 수 있는 전역 공유 메모리.
- Spring 컨테이너가 싱글톤 스코프의 빈을 생성할 때 **빈은 힙에 올라간다.**

# 스프링에서의 스레드, 스레드풀
### 서블릿
>웹 애플리케이션에서 HTTP 프로토콜을 사용해 클라이언트의 요청을 처리하고, 그 결과를 응답하는 클래스이다.

### 서블릿 컨테이너
> 서블릿을 지원하는 WAS(ex 톰캣)이며 서블릿 객체의 생명주기(생성/초기화/호출/종료)를 관리해주는 것을 `서블릿 컨테이너`라고 한다.

- 서블릿 객체는 **싱글톤**으로 관리된다.\
  HTTP 요청/응답 정보는 클라이언트 마다 다른 정보를 가지므로 매 요청마다 새로운 객체가 생성되어야 한다.\
그러나 어플리케이션 로직이 들어 있는 서블릿 객체는 **하나만** 생성해두고 여러 클라이언트가 **재사용**하는것이 효율적이다.

따라서 최초 로딩 시점에 서블릿 객체 하나만 생성해두고 재활용한다면, 클라이언트 요청은 동일한 서블릿 객체 인스턴스에 접근할 수 있다. 또, 서블릿 객체 인스턴스가 요청을 처리하며 싱글톤 `빈`을 사용하더라도, 스레드가 Heap에 위치한 Bean에 접근하여 요청을 처리한다.

![](https://velog.velcdn.com/images/oyoungsun/post/5772528b-f94d-44ce-8e82-1ec101fcf4b3/image.png)
![](https://velog.velcdn.com/images/oyoungsun/post/c4fe01e8-74ef-44c3-b340-3adf417f128b/image.png)

컨테이는 사용자로부터 요청을 받을 때 마다 요청을 처리할 스레드를 생성한다.\
그리고 그 스레드에서 **필요한 서블릿 메소드를 호출한다**. \
이때 스프링은 새로운 스레드를 생성하지 않고, 컨테이너 내부에 스레드풀(Thread pool)에서 스레드를 꺼내 사용한다.

여기서 유의해야 할 점은 요청이 올 때 마다 스레드를 새로 생성하거나 스레드 풀에서 쓰는 것이지 **서블릿 인스턴스를 새로 생성하는 것은 아니다.**

### 스레드풀
스레드 풀은 필요한 쓰레드를 쓰레드 풀에 보관하고 관리하며, 쓰레드가 필요한 경우 풀에서 할당해 사용하고 종료시 풀에 다시 반납하면 된다.

또한 생성 가능한 쓰레드의 최대치를 설정 가능하다. 만약 최대 쓰레드가 모두 사용 중인 경우에는 요청을 거절하거나 특정 숫자만큼 `대기` 하도록 설정할 수 있다.

### 💡 왜 스레드 풀을 써야하는가
쓰레드 생성/종료하는 비용(CPU)이 절약 되며, 응답 시간이 빨라진다. 또한, 개발자가 멀티 스레드 관련 코드를 신경쓰지 않아도 되어 생산성이 증가한다.

# References
[[운영체제] 프로세스 스레드 면접 대비 질문 정리] (https://deious.tistory.com/288#%F0%9F%92%A1%C2%A0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EC%97%90%20%EB%8C%80%ED%95%B4%20%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94.-1)
[서블릿(Servlet)이 뭔지 궁금해?]
(https://jh2021.tistory.com/20)
[[Spring] 싱글톤 빈이 동시 요청을 처리하는 방법](https://leezzangmin.tistory.com/41)
