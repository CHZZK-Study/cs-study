# Tree

- Array, Linked List, Stack,. Queue는 라인처럼 생긴 일직선 데이터구조이지만 Tree는 부모 자식 관계를 가지는 구조이다
- 그래서 Tree는 계층이고 그룹이다 이점이 가능한것은 노드가 하나 이상의 자식을 갖기 때문이다
- Tree의 노드중에는 부모를 아는 경우도 있고 자식만 아는 경우도 있다
- 특정 순서에 의해서 관리되는 경우, 데이터가 섞여있는 경우도 있다
- Tree의 맨 끝에 더이상 자식이 없는 노드를 leaf 잎사귀라고 표현한다

<br>
<br>

# Binary Tree 이진트리

노드가 하나 이상의 자식을 가지면 Tree 라고 부른다

그 중 자식노드가 최대 2개 까지만 붙는 Tree를 이진 트리라고 부른다

각 노드가 2개 이상의 자식을 가지는 트리를 **다항 트리 (Multiway Tree)**라고 칭한다. 이 용어는 특히 자식 노드의 수에 제한이 없는 경우에 사용된다.

각 노드가 정확히 3개의 자식을 가지는 트리는 **3진 트리 (ternary tree)** 라고도 불린다.

### 구조와 용어

1. 루트 노드 (Root Node): 트리의 최상위 노드로,모든 경로는 이 루트 노드에서 시작한다.
2. 자식 노드 (Child Node): 각 노드는 최대 두 개의 자식 노드를 가질 수 있다.
3. 부모 노드 (Parent Node): 특정 노드의 바로 위에 있는 노드를 가리킵니다.
4. 단말 노드 (Leaf Node, Terminal Node): 자식 노드가 없는 노드로,트리의 끝 부분에 위치한다.
5. 내부 노드 (Internal Node): 단말 노드를 제외한 모든 노드를 말한다.

### 특징

**재귀적 구조**

각 노드는 다시 이진 트리의 루트가 될 수 있으며, 이 특징을 잘 활용하면 재귀적인 알고리즘을 구현할 수 있다.

**탐색 및 정렬**

이진 트리는 정렬된 데이터를 효율적으로 탐색하고,데이터를 정렬하는 데 사용된다.

**평균 시간복잡도**

삽입,삭제,검색에 대한 평균 시간복잡도는 O(log N)이다 (단,이진 탐색 트리의 경우, 트리가 균형을 유지해야 함)

### 종류

**이진 탐색 트리 (BST, Binary Search Tree)**

각 노드의 왼쪽 자식 노드는 현재 노드보다 작은 값이고, 오른쪽 자식 노드는 현재 노드보다 큰 값을 갖는 특징을 갖는다

**AVL 트리**

균형을 유지하는 이진 탐색 트리로, 각 노드의 서브트리 높이 차이가 1이하를 유지하여 균형을 유지한다.

**레드-블랙 트리 (Red-Black Tree)**

삽입,삭제 시에 균형을 유지하여 시간복잡도 O(log N)을 유지하는 트리 구조이다.

이진 트리는 효율적인 데이터 저장과 탐색을 위한 기반 구조로, 다양한 분야에서 활용

그러나 균형을 유지하지 않을 때는 최악의 경우 시간복잡도가 선형에 가깝게 나타날 수 있으므로 균형을 유지하는 특별한 종류의 이진트리가 사용되기도 한다.

<br>
<br>

# Binary Search Tree 이진 검색 트리

### Binary Search Tree

- 이진 검색 트리는 안에 데이터가 왼쪽 노드와 그 이하 자식 노드들은 현재 노드보다 작아야 한다
- 오른쪽 노드와 그 이하 자식 노드들은 현재 노드 보다 커야 한다
- 그렇기 때문에 노드를 보고 해당 노드의 값보다 큰 값을 찾고 싶으면 오른쪽으로 작은 값을 찾으려면 왼쪽으로 가면 된다
  <br>
  <br>

**이진 탐색**: 탐색 시간 복잡도 O(log N), 삽입이나 삭제 불가능

**연결 리스트**: 탐색 시간복잡도 O(N), 삽입이나 삭제 시 O(1) 소요

이 둘의 장점을 챙긴 자료구조가 이진 검색 트리이다

**탐색 효율을 높이고 자료의 삽입과 삭제도 가능하게 하는것이 핵심이다**
<br>
<br>

### 특징

**정렬된 구조**

각 노드의 왼쪽 서브트리는 해당 노드보다 작은 값들을, 오른쪽 서브트리는 해당 노드보다 큰 값들을 포함하고 있으므로, BST는 항상 정렬된 상태를 유지한다.

**탐색 효율성**

BST는 데이터를 검색하는 데 빠른 속도를 제공한다.

특정 값을 찾을 때는 이진 탐색의 원리를 따라서 루트에서부터 시작하여 탐색한다.

**삽입과 삭제**

삽입과 삭제 시에도 정렬된 상태를 유지하기 위해 노드를 적절한 위치에 삽입하거나 삭제한다.

<br>
<br>

### 동작 원리

**삽입**

삽입할 값을 비교하여 노드를 찾은후, 해당 위치에 노드를 삽입한다.

- 새로운 데이터가 들어갈 자리가 비어 있다면 그대로 값을 삽입

작으면 왼쪽으로 크면 오른쪽으로 이동하며 비어있는 위치를 찾아 삽입한다.

- 자리가 비어있지 않다면 해장 자리의 노드 값과 비교
- 삽입할 데이터보다 작다면 **왼쪽 서브 트리**로 이동
- 삽입할 데이터보다 크다면 **오른쪽 서브 트리**로 이동

**삭제**

삭제할 값을 찾은 후에는 다음과 같은 경우를 고려하여 삭제한다

삭제할 노드가 단말 노드(leaf)인 경우

- 해당 노드를 삭제한다.

삭제할 노드가 자식 노드를 하나 갖고 있는 경우

- 해당 노드를 삭제하고 자식노드를 부모 노드에 연결한다.

삭제할 노드가 두개의 자식 노드를 갖고 있는 경우

- 삭제할 노드와 가장 근사한 값을 가진 노드(직후 노드 또는 직전 노드)를 삭제할 노드 위치로 가져온다
- 오른쪽 서브 트리의 MIN 값 혹은 왼쪽 서브 트리의 MAX 값을 가져온다

### 시간복잡도

BST의 평균적인 탐색,삽입,삭제 연산의 시간 복잡도는 O(log N)이다.

그러나 트리가 불균형할 떄 최악의 경우 O(N)이 될 수 있다

BST는 정렬된 상태를 유지하면서 데이터를 효율적으로 관리할 수 있는 장점이 있지만, 트리가 균형을 잘 유지하지 못하면 성능이 저하될 수 있으므로, 균형을 유지하는 방법에 대한 고려가 중요하다.

AVL 트리나 레드-블랙 트리 등의 균형을 유지하는 특별한 종류의 BST가 사용될 수 있다

<br>
<br>

# Red-black tree 레드-블랙 트리

레드-블랙 트리는 **자가 균형 이진 탐색 트리**이다

- 데이터가 삽입되거나 삭제될 때 자동으로 균형을 유지하는 트리

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/red-black-tree.png">

1. 모든 노드는 빨간색 혹은 검은색이다.
2. 루트 노드는 검은색이다.
3. 모든 리프 노드는 블랙이다.
   1. 사각형으로 된 리프 노드는 여기서 NIL 노드라고 부른다.
   2. 이 노드는 따로 key나 data를 포함하지 않은 “완전 가상의 노드”
4. 빨간색 노드의 자식은 검은색이다
   1. No Double Red(빨간색 노드가 연속으로 나올 수 없다)
5. 모든 리프 노드에서 Black Depth는 같다
   1. 리프 노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드의 개수가 같다.

<br>
<br>

RB Tree의 가장 큰 특징은 삽입, 삭제 동안 트리의 모양아 “균형 잡히도록” 각 노드들은 red or black 색상을 가지는 것인데 검색,삽입,삭제 시 Worst Case에서도 모두 **O(log N)** 이 보장되는 자료구조

레드-블랙 트리에 새로운 노드를 삽입할 때 **새로운 노드는 항상 빨간색**으로 삽입한다 하지만 그렇게 되면 **빨간색 노드가 연속으로 2번 나타나게 된다 (Double Red)**

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/red-black-tree-DoubleRed.png">

레드 블랙 트리는 이 문제를 해결하기 위한 **2가지 스킬**을 사용한다

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/red-black-tree-RESREC.png">

새로 삽입할 노드를 `N`(New), 부모 노드를 `P`(Parent), 조상 노드를 `G`(Grand Parent), 삼촌 노드를 `U`(Uncle)라고 할 때 삼촌 노드는 말 그대로 부모의 형제이다.

Double Red가 발생 했을 때

- U 삼촌 노드가 검은색이라면 → Restructuring을 수행
- U 삼촌 노드가 빨간색이라면 → Recoloring을 수행

### Restructuring

삽입 또는 삭제로 인해 균형이 깨지는 경우, 회전 연산을 통해 트리의 구조를 변경하는 작업

### Recoloring

삽입 또는 삭제로 인해 균형이 깨지는 경우, 노드의 색상을 변경하는 작업

Restructuring과 Recoloring으로 RB 트리 구조를 계속 유지해 준다

<br>
<br>

# Balanced

트리에서 밸런스가 맞다 안맞다는 정확히 일치하지 않아도 지나치게 치우쳐 있지만 않으면 밸런스가 맞다고 표현한다.

Balanced가 맞는 대표적인 Tree

- red-black tree
- AVL tree

<br>
<br>

# Complete Binary Tree 완전 이진 트리

마지막 레벨을 제외한 모든 서브트리의 레벨이 같고 마지막 레벨이 왼쪽부터 채워져 있다면 완전 이진 트리

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/cbt.png">

<br>
<br>

# Full Binary Tree

Full Binary Tree는 자식 노드를 가질거면 둘을 갖고 안가질거면 아예 없는 Tree이다

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/fbt.png">

<br>
<br>

# Perfect Binary Tree 포화 이진 트리

이진 트리 중에서도 모든 노드가 2개의 자식을 가지고 leaf노드가 모두 같은 레벨 일 때를 말한다

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/pbt.png">

<br>
<br>

# Binary Tree Traversal

### Binary Tree의 데이터를 가져오는 방법

1. Inorder 중위순회 (Left, Root, Right)
2. Preorder 전위순회 (Root, Left, Right)
3. Postorder 후위순회 (Left, Right, Root)

### Inorder 중위순회

트리의 모든 노드를 왼쪽 서브트리, Root, 오른쪽 서브트리 순서로 순회하는 방법

이 방법은 깊이 우선 탐색(DFS)의 한 형태로 사용되며, 특정 노드의 값을 출력하거나 트리의 노드들을 정렬된 순서로 방문할 떄 유용하다.

1. 왼쪽 서브트리를 순회
2. 현재 노드의 값을 처리
3. 오른쪽 서브트리를 순회

위 과정을 재귀적으로 수행하면서 모든 노드를 탐색한다.

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/Traversal.png">

**순서 A > B > C > D > E > F > G > H > I**

### Preorder 전위순회

트리의 모든 노드를 자기 자신을 먼저 처리한 후 왼쪽 서브트리, 오른쪽 서브트리 순서로 순회하는 방법

이 방법은 깊이 우선 탐색(DFS)의 한 형태로 사용되며, 특정 노드의 값을 출력하거나 트리의 노드들을 특정한 순서로 방문할 때 유용하다.

1. 현재 노드의 값을 처리
2. 왼쪽 서브트리를 순회
3. 오른쪽 서브트리를 순회

위 과정을 재귀적으로 수행하면서 모든 노드를 탐색한다.

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/Traversal.png">

**순서 F > B > A > D > C > E > G > I > H**

즉 노드를 먼저 방문하고 왼쪽 끝까지 내려간 다음 오른쪽으로 이동하여 다시 시작하거나 오른쪽으로 디오하여 순회를 계속 한다

### Postorder 후위순회

트리의 모든 노드를 왼쪽 서브트리,오른쪽 서브트리를 순회한 후에 자기 자신을 처리하는 방법이다.

깊이 우선 탐색(DFS)의 한 형태로 사용되며, 트리의 리프 노드부터 루트 노드 까지 순서대로 방문할 떄 유용하다.

1. 왼쪽 서브트리를 순회
2. 오른쪽 서브트리를 순회
3. 현재 노드의 값 처리

위 과정을 재귀적으로 수행하면서 모든 노드를 탐색한다.

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/Traversal.png">

**순서 A > C > E > D > B > H > I > G > F**

<br>
<br>

# Binary Heaps

### Heap이란

최댓값이나 최솟값을 찾아내는 연산을 빠르게 하기위해 고안된 Complete Binary Tree 완전 이진트리를 기본으로한 자료구조

Heap에는 두 가지 Min Heap(최소힙)과 Max Heap(최대힙)이 있다

Min Heap에는 작은 값을 항상 위에 노드에 있게해서 Tree의 Root에는 가장 작은 값이 오도록 하는것

Max Heap에는 가장 큰 값이 맨 위에 노드에 오도록 모든 노드들은 자기 부모노드에 자기보다 큰 값을 가지는것

<img src="https://github.com/KKYHH/cs-study/blob/main/2%EC%A3%BC%EC%B0%A8/%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A9/heap.png">

### 최소힙에 노드 삽입하기

최소힙에 노드를 삽입하려면 완전트리에 맨 끝에 노드를 추가한다

트리가 Complete Binary Tree 완전트리 형태를 잃지 않도록 마지막 레벨의 왼쪽부터 추가한다

추가한 직후에는 데이터가 Tree 안에서 정렬되어있지 않은 상태

그래서 다음으로는 자신의 부모 노드와 비교해서 자기가 값이 작으면 부모 노드와 자리를 바꾼다

그렇게 계속 부모노드와 비교를 하며 부모 노드의 값이 자기보다 작을 때까지 올라간다

이 작업은 밸런스가 맞춰져 있는 Complete Binary Tree 완전이진트리에서 이루어지니까 한 레벨씩 루트까지 올라간다면 한 번 돌 때마다 절반씩 떨어지기 때문에 O(logn)의 시간 복잡도를 가진다

### 최소힙에서 노드 꺼내오기

최소힙에 노드를 요청할 때는 가장 작은 값을 요청한다는것

최소힙에서 가장 작은 값은 Root에 있으니까 가져오는건 어렵지 않다

하지만 Root의 값을 빼버리면 Root의 자리가 비어버리니까 다시 채워줘야한다

그래서 Root값을 꺼낸 후에 Complete Binary Tree 완전 이진 트리의 맨 마지막 노드를 가져와서 Root에 채운다

채운직후는 노드가 정렬이 되어있지 않기에 이번에는 자식노드와 비교를 해서 자신보다 작은 노드와 자리를 바꾼다

이 작업은 Root에서 한 레벨씩 내려가다가 맨 마지막 레벨 leaf까지 도달하게 되며 최대 O(logn)의 시간이 걸린다

끝에 삽입하고 위로 올라가는것과 마찬가지로 한 번 돌 때마다 가야할 길이 절반씩 떨어진다

<br>
<br>

# Trie Tree

### Trie는?

Trie는 특별히 문자열에서 검색을 빠르게 해주는 Tree 구조이다

검색트리의 일종

문자열 검색에 사용되는 자료구조

### 노드와 연결 구조

Trie의 각 노드는 문자를 나타낸다.

root 노드부터 시작하여 각 문자마다 자식 노드를 갖는다

각 노드는 자식 노드를 연결하는데,이 연결은 문자열을 형성한다.

노드 사이의 연결은 문자열의 각 문자에 해당한다.

### 단어 저장

단어들을 Trie에 저장할 때, root 노드부터 시작하여 각 문자를 순서대로 추가한다.

“cat”을 저장할 때, ‘c’→’a’→’t’ 순서대로 노드를 연결한다.

“dog”을 저장할 때,’d’→’o’→’g’ 순으로 연결한다.

### 탐색과 검색

Trie는 효율적인 검색을 가능하게 한다.

특정 단어가 Trie에 저장되어 있는지를 빠르게 찾을 수 있다

“car”가 Trie에 저장되어 있는지 검색하려면,root 노드부터 시작하여 ‘c’→’a’→’r’ 순서로 노드를 따라가면 된다

만약 “carts”를 검색한다면, ‘c’ → ‘a’ → ‘r’로 가면서 ‘t’ 노드까지 이어가다가 더 이상 연결된 노드가 없으면 해당 단어가 Trie에 없음을 알 수 있다

### 자동 완성과 접두사 검색

Trie는 특정 단어로 시작하는 모든 단어를 찾거나, 자동 완성 기능을 구현하는 데에도 사용된다.

접두사 검색도 가능하다.

“ca”로 시작하는 모든 단어를 찾거나, “car”와 관련된 모든 단어를 찾을 때 Trie가 효율적으로 활용된다.

Trie의 장점 중 하나는 검색 속도가 매우 빠르다는 점.

하지만 메모리 사용량이 크게증가할 수 있으므로, 데이터 양이 많거나 대규모 텍스트 검색에 유용하게 사용된다.
